# Design

## Team 3

- Steven Capleton
- Landon Dyken
- Karen Horton
- Eric Latham
- Brittany Latham
- Laura Thompson

## Overview

We will build an event-based smart home dashboard simulator application that operates according to the following process:

- The database stores generated weather and family **events** that describe when and how the smart home state changed over a 2-month period.
- The app runs on a **custom clock** to simulate fast-moving time, and the speed of simulated app time is adjustable by the user.
- The backend executes two **scheduled tasks** on intervals (according to app time):
  1. The backend **queries** the current month's events from the database into an event queue at the beginning of **each month** in the simulation.
  2. The backend **publishes** all unpublished past events waiting on the event queue to be processed and displayed on the frontend at the beginning of **each half minute** in the simulation.

### Key Details

- Each event's `time` value is the number of seconds after the start of the simulated 2-month time period at which the event occurred.
- When an event is "processed", its changes are applied to the application's smart home object.

## In Depth

### Historical Data Generation

We will generate weather and family event data for a 2-month time period and store it in a database.

- The data should be event-based; we should only store entries in the database for events that cause the smart home state to change.
- Each event should include a timestamp and specify how and why the smart home state changed.

### Application Runtime Model

#### Application Clock

The application clock represents the time in the application's 2-month simulation of smart home events.

Application time is real time multiplied by a user-adjustable speedup factor, so it is flexible and allows the user to run the smart home simulation at different speeds.

##### Minimum application clock speed:

```txt
1  real second  =  1  app second
```

##### Maximum application clock speed:

```txt
1   real minute   =  1          app month
60  real seconds  =  2,592,000  app seconds
1   real second   =  43,200     app seconds
```

#### Scheduled Tasks

The application should run scheduled tasks using a background scheduler on a daemon thread.

##### Event Queue

The application should use a custom queue data structure to store smart home events.

The event queue should store all of the events provided to it while only allowing past events to be retrieved. This will allow the application to poll the event queue at a regular time interval to get only the events that have "occurred" since the last poll.

Specifically, the event queue should:

- be instantiable with a list of event objects queried from the database
- use the application clock to determine if an event is a past or future event
- hide future events
- allow retrieving all unprocessed past events (to be processed)
- allow retrieving all processed past events (to be [analyzed](#data-analysis))

##### Monthly Event Querying

The application should query all of the events for the current month from the database into the event queue at the beginning of each month of application time.

This will minimize the number of queries and subsequently reduce network latency costs.

##### Half-Minutely Event Publishing

Based on [this guide](https://www.velotio.com/engineering-blog/how-to-implement-server-sent-events-using-python-flask-and-react), the application should use an SSE (server-sent-events) model to publish events to be processed and displayed to the user at the beginning of each half minute of application time.

Basically, the backend will retrieve all unprocessed past events from the event queue and then do the following with each one:

- process it (apply its changes to the smart home object)
- send it as an SSE to the frontend

Benefits of SSE:

- The SSE model is a more efficient alternative to the request model; the request model would require the frontend to constantly send requests (thousands in our case) to the backend for updates, while the SSE model allows the frontend to simply subscribe to a message channel that the backend publishes events to.
- SSEs are less expensive and time-consuming than HTTP requests, so the SSE model allows the app to consume events faster and with more granularity to time.
- With the SSE model, the frontend will only need to send explicit requests to the backend for user actions.

### Live User Interaction

The user should be able to:

- set the thermostat
- turn lights on and off
- open and close windows and doors

Each of these user actions should:

- insert an event into the database
  - user-generated events should be inserted with a special flag to denote that they were generated by the user
  - we may want to clear the database of user-generated events on application startup
- update the smart home state in memory
- display a visible change in the user interface

### Data Analysis

#### Historical Utility Usage

TODO

#### Projected Utility Usage

The user should be able to view data for projected utility usage amounts and costs **for the current month** based on the events stored in the database for the current month.

The following specific data should be displayed:

- the projected water usage (in gallons) and the resulting cost
- the projected electricity usage (in kilowatt-hours) and the resulting cost
- the projected total utility cost (water + electricity)

Costs should be displayed in dollars.

## Questions

- What happens when the simulation ends? Can we loop without re-querying?
- What does the smart home state include?
- How should weather events be represented?
- How should family events be represented?
